<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ucapan Pernikahan</title>
    <link rel="icon" href="/asset/img/icon.svg" type="image/svg+xml" />

    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <link
      href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@300;400;600&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Scheherazade+New&family=Open+Sans&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        font-family: "Poppins", sans-serif;
        background-color: #383737; /* semi transparan hitam */
        text-shadow: none !important;
        overflow: hidden; /* Hide scrollbar during loading */
      }

      /* Preloader Styles */
      #preloader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #383737; /* Match body background */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999; /* Ensure it's on top */
        color: white;
        transition: opacity 0.5s ease;
        opacity: 1;
      }

      #preloader.hidden {
        opacity: 0;
        visibility: hidden;
      }

      .loader {
        width: 100px;
        height: 100px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid rgb(252, 202, 140);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .progress-container {
        width: 80%;
        max-width: 300px;
        background-color: #555;
        border-radius: 5px;
        height: 15px;
        margin-bottom: 10px;
        overflow: hidden;
      }

      #progressBarFill {
        height: 100%;
        width: 0%;
        background-color: rgb(252, 202, 140);
        border-radius: 5px;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 0.9rem;
        margin-bottom: 5px;
        text-align: center;
      }

      .percentage-text {
        font-size: 1.1rem;
        font-weight: bold;
        text-align: center;
      }

      /* Initial Message Styles */
      #initialMessage {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #383737; /* Match body background */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9998; /* Below preloader, above content */
        color: white;
        text-align: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s ease;
      }

      #initialMessage.show {
        opacity: 1;
        visibility: visible;
      }

      #initialMessage p {
        font-size: 1.8rem;
        margin-bottom: 30px;
        font-weight: 700;
        font-family: "Poppins", cursive; /* Use a fancy font for the message */
        color: rgb(252, 202, 140);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      #initialMessage button {
        background-color: rgb(252, 202, 140);
        color: #383737;
        border: none;
        padding: 12px 25px;
        border-radius: 30px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      #initialMessage button:hover {
        background-color: rgb(240, 190, 130);
        transform: translateY(-2px);
      }

      /* Existing styles */
      .handwriting-heading {
        font-family: "Great Vibes", cursive;
        font-size: 2.2rem;
      }

      .mobile-wrapper {
        max-width: 430px;
        margin: auto;
        border: 1px solid #ddd;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        height: calc(
          var(--real-vh, 1vh) * 100
        ); /* pakai tinggi nyata dari JS */
        overflow: hidden;
        background-image: url("/asset/img/background.png");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        display: flex;
        flex-direction: column;
        color: white;
        text-shadow: 1px 1px 2px black;
        position: relative;
        /* Initially hide content until preloader is done */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s ease;
      }

      .mobile-wrapper.show-content {
        opacity: 1;
        visibility: visible;
      }

      /* Container yang menampung semua komponen carousel */
      .carousel-container {
        flex: 1;
        overflow-y: hidden;
        scroll-behavior: smooth;
        position: relative;
      }

      /* Kontainer yang akan di-scroll dengan height = 300% karena 3 komponen */
      .carousel-inner {
        height: 300vh; /* 3 komponen, masing2 100vh */
        transition: transform 0.5s ease-in-out;
      }

      /* Setiap komponen full tinggi viewport .mobile-wrapper */
      .component {
        height: 100vh;
        padding: 30px 20px;
        box-sizing: border-box;
      }

      .component-1 {
        background: rgba(44, 44, 44, 0.8);
        color: #e6e6e6;
      }
      .component-2 {
        background: rgba(44, 44, 44, 0.8);
        color: #e6e6e6;
      }
      .component-3 {
        background: rgba(44, 44, 44, 0.8);
        color: #e6e6e6;
      }

      /* Vertical Progress Bar */
      .vertical-progress-bar {
        position: absolute;
        left: 15px; /* Adjust as needed for padding */
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 15;
      }

      .progress-segment {
        width: 8px; /* Default width for inactive state */
        height: 8px; /* Default height for inactive state (makes it round) */
        background: rgba(255, 255, 255, 0.4);
        cursor: pointer;
        transition: all 0.3s ease; /* Smooth transition for all properties */
        border-radius: 50%; /* Make it round by default */
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-sizing: border-box; /* Include padding/border in element's total width/height */
      }

      .progress-segment.active {
        height: 40px; /* Taller for active state */
        border-radius: 4px; /* Rounded corners for bar shape */
        background: rgba(252, 202, 140, 0.9);
        border-color: rgba(252, 202, 140, 1);
        transform: scale(1.1); /* Slightly enlarge active segment */
      }

      .progress-segment:hover {
        background: rgba(255, 255, 255, 0.7);
        transform: scale(1.05);
      }

      .progress-segment.active:hover {
        background: rgb(252, 202, 140);
        transform: scale(1.1);
      }

      /* Tombol panah */
      .btn-scroll {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(252, 202, 140, 0.9);
        border: none;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        animation: floatUpDown 2s ease-in-out infinite;
        z-index: 10;
        transition: all 0.3s ease;
        opacity: 1;
        visibility: visible;
      }

      .btn-scroll.hidden {
        opacity: 0;
        visibility: hidden;
      }

      .btn-scroll:hover {
        background: rgb(252, 202, 140);
      }

      @keyframes floatUpDown {
        0%,
        100% {
          transform: translateX(-50%) translateY(0);
        }
        50% {
          transform: translateX(-50%) translateY(-10px);
        }
      }

      .btn-scroll svg {
        width: 24px;
        height: 24px;
        fill: #383737;
      }

      /* Animasi cincin */
      .ring-animation-container {
        height: 100%;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      .ring-icon {
        width: auto;
        height: 80px;
        opacity: 0;
        transform: scale(0);
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -40px;
        margin-top: -20px;
        transition: all 1s ease;
      }

      .ring-icon.animate {
        animation: ringPopUpAndMove 2.5s ease-in-out forwards;
      }

      @keyframes ringPopUpAndMove {
        0% {
          opacity: 0;
          transform: scale(0);
          top: 50%;
        }
        30% {
          opacity: 1;
          transform: scale(1.3);
          top: 50%;
        }
        50% {
          opacity: 1;
          transform: scale(1);
          top: 50%;
        }
        100% {
          opacity: 1;
          transform: scale(1);
          top: 30px;
        }
      }

      .wedding-text {
        opacity: 0;
        font-weight: bold;
        font-size: 1.6rem;
        color: #e6e6e6;
        text-align: center;
        margin-top: 96px;
        transition: opacity 0.8s ease;
      }

      .wedding-text.show {
        opacity: 1;
      }

      .wedding-text span {
        opacity: 0;
        transition: opacity 0.3s ease;
        display: inline-block;
      }

      .animated-image-row {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
        width: 100%; /* penuh lebar induk */
        height: auto; /* sesuaikan tinggi container */
        opacity: 0; /* awalnya sembunyi */
        transform: translateY(
          20px
        ); /* sedikit ke bawah untuk efek fade in dari bawah */
        transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
      }

      /* FIX: Tambahkan CSS untuk class show */
      .animated-image-row.show {
        opacity: 1;
        transform: translateY(0); /* kembali ke posisi normal */
      }

      .bounce-img {
        width: 100%; /* gambar mengisi tiap kolom */
        max-width: 200px; /* batas maksimal agar tidak terlalu besar */
        object-fit: contain;
        animation-duration: 1.5s;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
      }

      .bounce-img.left {
        animation-name: bounceUpDown;
      }

      .bounce-img.right {
        animation-name: bounceDownUp;
      }

      @keyframes bounceUpDown {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @keyframes bounceDownUp {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(10px);
        }
      }

      /* Font khusus untuk teks Arab atau transliterasi */
      .arabic-text {
        font-family: "Scheherazade New", "Amiri", serif; /* Font Arabic-style */
        font-size: 1.3rem;
        color: #ffbe69;
        display: block;
        margin-bottom: 10px;
      }

      /* Font berbeda untuk terjemahan */
      .translation {
        font-family: "Poppins", sans-serif;
        font-size: 1rem;
        color: #666;
      }

      /* Kontainer dan animasi */
      .wedding-blessing {
        text-align: center;
        margin-top: 20px;
        padding-right: 8px;
        padding-left: 8px;
        opacity: 0;
        transform: translateY(
          30px
        ); /* sedikit ke bawah untuk efek fade in dari bawah */
        transition: opacity 1s ease-in-out, transform 1s ease-in-out;
      }

      .wedding-blessing.show {
        opacity: 1;
        transform: translateY(0); /* kembali ke posisi normal */
      }

      /* Video Carousel Styles */
      .video-carousel-container {
        position: relative;
        width: 100%;
        max-width: 300px; /* Atur lebar maksimum carousel video */
        margin: 20px auto;
        overflow: hidden;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        opacity: 0; /* Awalnya tersembunyi untuk animasi AOS */
        transform: translateY(30px); /* Untuk efek fade-up AOS */
        transition: opacity 1s ease-in-out, transform 1s ease-in-out;
      }

      /* Menangani animasi AOS secara manual untuk video carousel container */
      .video-carousel-container.aos-animate {
        opacity: 1;
        transform: translateY(0);
      }

      .video-carousel {
        display: flex;
        transition: transform 0.5s ease-in-out;
      }

      .video-item {
        flex: 0 0 100%; /* Setiap item video mengambil 100% lebar carousel */
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      .video-item video {
        width: 100%;
        display: block; /* Menghilangkan spasi ekstra di bawah video */
        background-color: black; /* Latar belakang hitam untuk mengisi ruang jika video tidak pas */
      }

      .video-wrapper {
        width: 100%;
        padding-bottom: 133.33%; /* 4 / 3 = 1.3333, jadi 133.33% */
        position: relative;
        overflow: hidden; /* Penting untuk menjaga video tetap dalam rasio */
      }

      .video-wrapper video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain; /* Memastikan video pas dalam rasio tanpa terpotong */
      }

      .video-caption {
        margin-top: 10px;
        font-size: 0.9rem;
        color: #e6e6e6;
      }

      .carousel-control {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(252, 202, 140, 0.9);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 5; /* Di atas video */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: background 0.3s ease;
      }

      .carousel-control:hover {
        background: rgb(252, 202, 140);
      }

      .prev-video {
        left: 10px;
      }

      .next-video {
        right: 10px;
      }

      @media (max-width: 480px) {
        #initialMessage p {
          font-size: 1.5rem;
        }
        #initialMessage button {
          font-size: 1rem;
          padding: 10px 20px;
        }

        .wedding-text {
          font-size: 1.2rem;
          margin-top: 96px;
        }

        .arabic-text {
          font-size: 1.05rem;
          margin-bottom: 8px;
        }

        .translation {
          font-size: 0.9rem;
        }

        .animated-image-row {
          align-items: center;
          gap: 15px;
        }

        .bounce-img {
          max-width: 150px; /* lebih kecil di layar kecil */
        }

        .vertical-progress-bar {
          left: 10px; /* Smaller left padding on small screens */
        }

        /* Adjustments for progress segments on small screens */
        .progress-segment {
          width: 6px; /* Slightly smaller width for inactive */
          height: 6px; /* Slightly smaller height for inactive */
        }

        .progress-segment.active {
          height: 30px; /* Shorter segments on small screens */
        }

        .carousel-control {
          width: 35px;
          height: 35px;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="preloader">
      <div class="loader"></div>
      <div class="progress-text">
        Mengunduh aset: <span id="downloadedSize">0 MB</span> /
        <span id="totalSize">0 MB</span>
      </div>
      <div class="progress-container">
        <div id="progressBarFill"></div>
      </div>
      <div class="percentage-text"><span id="progressPercentage">0</span>%</div>
    </div>

    <div id="initialMessage">
      <p>Halo, ada pesan Nih dari <br>TTPKN 4/20! 💌</p>
      <button id="viewMessageButton">Lihat Pesan</button>
    </div>

    <audio id="backgroundMusic" loop>
      <source src="/asset/music/bg-music.mp3" type="audio/mp3" />
      Your browser does not support the audio element.
    </audio>
    <div class="mobile-wrapper">
      <div class="carousel-container" id="carouselContainer">
        <div class="carousel-inner" id="carouselInner">
          <div class="component component-1">
            <div class="content text-center" data-aos="fade">
              <h1 class="handwriting-heading mb-4">
                Dari
                <span style="color: rgb(252, 202, 140); font-weight: bold"
                  >Mula</span
                ><br />
                hingga Hari
                <span style="color: rgb(252, 202, 140); font-weight: bold"
                  >Bahagia</span
                >
              </h1>
              <img
                src="/asset/img/msrizal1.png"
                alt="Gambar 1"
                style="
                  max-width: 100%;
                  border-radius: 10px;
                  margin-top: 20px;
                  margin-bottom: 20px;
                "
              />
              <img
                src="/asset/img/msrizal2.png"
                alt="Gambar 2"
                style="max-width: 100%; border-radius: 10px"
              />
            </div>
          </div>
          <div class="component component-2">
            <div class="content">
              <div class="ring-animation-container">
                <img
                  id="ringIcon"
                  src="/asset/img/ring-icon.png"
                  alt="Ring Icon"
                  class="ring-icon"
                />
                <div id="weddingText" class="wedding-text">
                  Happy Wedding<br />Mas Rizal & Mbak Desy
                </div>
                <div class="animated-image-row" id="animatedImages">
                  <img
                    src="/asset/img/component2-1.png"
                    alt="Flower Left"
                    class="bounce-img left"
                  />
                  <img
                    src="/asset/img/component2-2.png"
                    alt="Flower Right"
                    class="bounce-img right"
                  />
                </div>
                <div class="wedding-blessing" id="weddingBlessing">
                  <span class="arabic-text">
                    Baarakallahu laka wa baaraka 'alayka, wa jama'a baynakumaa
                    fii khayr. </span
                  ><br />
                  <span class="translation">
                    Semoga Allah memberkahimu dan pasanganmu, serta mengumpulkan
                    kalian dalam kebaikan.
                  </span>
                </div>
              </div>
            </div>
          </div>
          <div class="component component-3">
            <div class="content text-center">
              <h2 class="animated-heading" id="heading3">
                Kata-kata dong untuk mereka ✨
              </h2>
              <p class="animated-subtext" id="subtext3">
                Slide sampai akhir ya... 👉
              </p>

              <div class="video-carousel-container" id="videoCarouselContainer">
                <div class="video-carousel" id="videoCarousel"></div>
                <button class="carousel-control prev-video" id="prevVideoBtn">
                  <svg
                    viewBox="0 0 24 24"
                    aria-hidden="true"
                    style="fill: #383737"
                  >
                    <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" />
                  </svg>
                </button>
                <button class="carousel-control next-video" id="nextVideoBtn">
                  <svg
                    viewBox="0 0 24 24"
                    aria-hidden="true"
                    style="fill: #383737"
                  >
                    <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z" />
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="vertical-progress-bar" id="progressBar">
        <div class="progress-segment active" data-index="0"></div>
        <div class="progress-segment" data-index="1"></div>
        <div class="progress-segment" data-index="2"></div>
      </div>

      <button
        class="btn-scroll"
        id="btnScroll"
        aria-label="Scroll ke komponen berikutnya"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z" />
        </svg>
      </button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.js"></script>

    <script>
      AOS.init({
        duration: 1000, // Durasi default untuk animasi
        once: true, // Animasi hanya berjalan sekali
      });

      const btnScroll = document.getElementById("btnScroll");
      const carouselInner = document.getElementById("carouselInner");
      const progressBarSegments =
        document.querySelectorAll(".progress-segment");
      const ringIcon = document.getElementById("ringIcon");
      const weddingText = document.getElementById("weddingText");
      const animatedImages = document.getElementById("animatedImages");
      const weddingBlessing = document.getElementById("weddingBlessing");

      const backgroundMusic = document.getElementById("backgroundMusic");

      // Elemen-elemen untuk Component 3
      const heading3 = document.getElementById("heading3");
      const subtext3 = document.getElementById("subtext3");
      const videoCarouselContainer = document.getElementById(
        "videoCarouselContainer"
      );

      // Video Carousel Elements
      const videoCarousel = document.getElementById("videoCarousel");
      const prevVideoBtn = document.getElementById("prevVideoBtn");
      const nextVideoBtn = document.getElementById("nextVideoBtn");

      // --- Preloader Elements ---
      const preloader = document.getElementById("preloader");
      const progressBarFill = document.getElementById("progressBarFill");
      const downloadedSizeSpan = document.getElementById("downloadedSize");
      const totalSizeSpan = document.getElementById("totalSize");
      const progressPercentageSpan =
        document.getElementById("progressPercentage");

      // --- Initial Message Elements ---
      const initialMessage = document.getElementById("initialMessage");
      const viewMessageButton = document.getElementById("viewMessageButton");
      const mobileWrapper = document.querySelector(".mobile-wrapper");

      // --- Daftar Video & Caption (PERHATIAN: PERLU DIISI MANUAL jika tanpa sisi server) ---
      const videoFilenames = [
        "RIAN.mp4",
        "ARES.mp4",
        "ARVA.mp4",
        "FAIT.mp4",
        "OCIT.mp4",
        "OPUNG.mp4",
        "YUGI.mp4",
        "ZIDAN.mp4",
        // Tambahkan semua nama file .mp4 Anda di sini
      ];

      const allCaptions = [
        "Semoga cinta kalian abadi hingga jannah!",
        "Selamat menempuh hidup baru, semoga sakinah mawaddah warahmah.",
        "Happy Wedding! Semoga menjadi keluarga yang selalu berbahagia.",
        "Turut berbahagia atas pernikahan kalian, Mas Rizal & Mbak Desy!",
        "Langgeng terus ya sampai kakek nenek, samawa!",
        "Barakallahu lakuma! Semoga diberkahi Allah SWT.",
        "Ikut terharu melihat kebahagiaan kalian. Selamat menikah!",
        "Selamat atas babak baru kehidupan kalian. Indah sekali!",
        "Momen paling spesial! Selamat menempuh bahtera rumah tangga.",
        "Semoga selalu dilimpahi keberkahan dan kebahagiaan.",
        "Selamat menempuh perjalanan cinta yang tak berujung.",
        "Kisah cinta kalian adalah inspirasi. Selamat, pasangan serasi!",
        "Doa terbaik untuk kalian berdua di hari bahagia ini.",
        "Cinta sejati telah menemukan jalannya. Selamat menikah!",
        "Semoga setiap hari kalian dipenuhi tawa dan cinta.",
        "Happy Ever After, Mas Rizal dan Mbak Desy!",
        "Hari ini adalah awal dari selamanya. Selamat!",
        "Semoga cinta kalian tumbuh kuat setiap hari.",
        "Selamat atas ikatan suci ini, semoga langgeng selamanya.",
        "Dari hati yang terdalam, selamat atas pernikahan kalian!",
      ];

      const videoList = [];
      const usedCaptions = new Set();

      function getRandomCaption() {
        let availableCaptions = allCaptions.filter(
          (caption) => !usedCaptions.has(caption)
        );
        if (availableCaptions.length === 0) {
          usedCaptions.clear();
          availableCaptions = allCaptions;
        }
        const randomIndex = Math.floor(
          Math.random() * availableCaptions.length
        );
        const selectedCaption = availableCaptions[randomIndex];
        usedCaptions.add(selectedCaption);
        return selectedCaption;
      }

      videoFilenames.forEach((filename) => {
        videoList.push({
          filename: filename,
          caption: getRandomCaption(),
        });
      });

      const videoBasePath = "/asset/img/";

      let currentVideoIndex = 0;
      let totalVideos = 0;

      let currentIndex = 0;
      const maxIndex = 2;
      let textAnimationPromise = null;

      let animationTimeouts = [];
      let animationInProgress = false; // Indicates if any animation for component 2 is currently running/scheduled
      let component2AnimationCompleted = false; // New flag to track if component 2 animation has fully finished

      // --- Preloader Logic ---
      // Remove ASSET_SIZES if you want to rely purely on Content-Length,
      // but keep it as a fallback or for assets where Content-Length might not be consistently sent.
      // const ASSET_SIZES = { ... }; // You might still keep this for fallback/initial estimation

      let totalExpectedBytes = 0; // This will now be dynamically calculated
      let loadedBytes = 0;

      // Add main images and music
      const initialAssets = [
        "/asset/music/bg-music.mp3",
        "/asset/img/background.png",
        "/asset/img/msrizal1.png",
        "/asset/img/msrizal2.png",
        "/asset/img/ring-icon.png",
        "/asset/img/component2-1.png",
        "/asset/img/component2-2.png",
      ];

      // Add video paths for metadata loading (we'll fetch them to get content-length)
      const videoAssetPaths = videoFilenames.map(
        (filename) => `${videoBasePath}${filename}`
      );

      const assetsToLoad = [...initialAssets, ...videoAssetPaths];

      // Initially, estimate total size or set to 0.
      // We'll update totalExpectedBytes as we get Content-Length from responses.
      totalExpectedBytes = 0; // Initialize to 0, it will be populated as we get actual sizes

      // Function to update progress display
      function updateProgress(currentLoadedBytes, currentTotalExpectedBytes) {
        // Ensure totalExpectedBytes is not zero to prevent division by zero
        const percentage =
          currentTotalExpectedBytes > 0
            ? Math.min(
                100,
                Math.floor(
                  (currentLoadedBytes / currentTotalExpectedBytes) * 100
                )
              )
            : 0;

        progressBarFill.style.width = `${percentage}%`;
        downloadedSizeSpan.textContent =
          (currentLoadedBytes / (1024 * 1024)).toFixed(1) + " Mb";
        totalSizeSpan.textContent =
          (currentTotalExpectedBytes / (1024 * 1024)).toFixed(1) + " Mb";
        progressPercentageSpan.textContent = percentage;

        if (
          percentage >= 100 &&
          currentLoadedBytes >= currentTotalExpectedBytes
        ) {
          // Ensure both conditions for completion
          setTimeout(() => {
            preloader.classList.add("hidden");
            setTimeout(() => {
              initialMessage.classList.add("show");
              document.body.style.overflow = "hidden";
            }, 500);
          }, 300);
        }
      }

      async function loadAsset(url) {
        try {
          const response = await fetch(url, { method: "HEAD" }); // Use HEAD request to get headers first
          const contentLength = response.headers.get("content-length");
          let assetSize = 0;

          if (contentLength) {
            assetSize = parseInt(contentLength, 10);
          } else {
            // Fallback: If Content-Length is not available (e.g., CORS issues, or server doesn't send it)
            // You might use your ASSET_SIZES map here as a fallback or a default small size.
            console.warn(
              `Content-Length not available for ${url}. Using estimated size if available.`
            );
            // If ASSET_SIZES exists, you can use it here as a fallback:
            // assetSize = ASSET_SIZES[url] || (url.includes(".mp4") ? ASSET_SIZES["video_metadata"] : 0);
            // For now, we'll just return 0 if no Content-Length
            assetSize = 0; // Or a small default for unmeasurable assets
          }

          // Now, actually fetch the asset to mark it as 'loaded'
          // We're essentially doing a two-step: get size, then 'load' (which happens very fast now)
          const actualFetch = await fetch(url);
          if (!actualFetch.ok) {
            throw new Error(`HTTP error! status: ${actualFetch.status}`);
          }

          return assetSize; // Return the actual (or estimated) size
        } catch (error) {
          console.warn(`Failed to load asset or get size for ${url}:`, error);
          return 0; // Return 0 bytes on error
        }
      }

      async function startLoadingAssets() {
        let currentLoadedBytes = 0;
        let totalKnownBytes = 0;
        const assetSizes = {}; // Store known sizes here

        // First pass: Try to get total expected bytes by HEAD requests
        for (const assetPath of assetsToLoad) {
          try {
            const response = await fetch(assetPath, { method: "HEAD" });
            const contentLength = response.headers.get("content-length");
            if (contentLength) {
              const size = parseInt(contentLength, 10);
              totalKnownBytes += size;
              assetSizes[assetPath] = size;
            } else {
              // If Content-Length isn't available, make a reasonable estimate
              // You can uncomment and use your ASSET_SIZES object here if you have it
              // const estimatedSize = ASSET_SIZES[assetPath] || (assetPath.includes(".mp4") ? ASSET_SIZES["video_metadata"] : 0);
              // totalKnownBytes += estimatedSize;
              // assetSizes[assetPath] = estimatedSize;
              console.warn(
                `Content-Length not available for ${assetPath}. Skipping for total calculation for now.`
              );
            }
          } catch (error) {
            console.warn(`Failed HEAD request for ${assetPath}:`, error);
          }
        }
        totalExpectedBytes = totalKnownBytes; // Set the total expected bytes
        totalSizeSpan.textContent = (
          totalExpectedBytes /
          (1024 * 1024)
        ).toFixed(1); // Update total size display

        // Second pass: Actually load the assets and update progress
        for (const assetPath of assetsToLoad) {
          // You might not even need the 'loadAsset' function if you're just doing HEAD requests
          // and then letting the browser's normal loading handle the rest.
          // For a more precise progress bar *during* loading, you'd use fetch with readable streams.
          // However, for simply displaying the total loaded vs. total expected, this is simpler.

          // Simulate loading by waiting a bit and then adding the asset's size
          // In a real scenario, you'd track progress of the actual download.
          currentLoadedBytes += assetSizes[assetPath] || 0; // Add the known size
          updateProgress(currentLoadedBytes, totalExpectedBytes);
          // For a true progress bar, this is where you'd actually fetch the asset with progress
          // const res = await fetch(assetPath); // Or just let the browser fetch it normally.
          // If you really want detailed progress per asset:
          // const response = await fetch(assetPath);
          // const reader = response.body.getReader();
          // let receivedLength = 0; // bytes received
          // while (true) {
          //   const { done, value } = await reader.read();
          //   if (done) {
          //     break;
          //   }
          //   receivedLength += value.length;
          //   // Update progress here with (currentLoadedBytes - assetSizes[assetPath] + receivedLength)
          // }
        }
      }

      // --- End Preloader Logic ---

      function setRealViewportHeight() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty("--real-vh", `${vh}px`);
      }

      window.addEventListener("resize", setRealViewportHeight);
      window.addEventListener("orientationchange", setRealViewportHeight);

      document.addEventListener("DOMContentLoaded", () => {
        // Start preloading assets immediately
        startLoadingAssets();
        setRealViewportHeight();
      });

      viewMessageButton.addEventListener("click", () => {
        initialMessage.classList.remove("show");
        initialMessage.classList.add("hidden"); // Hide the initial message

        setTimeout(() => {
          mobileWrapper.classList.add("show-content"); // Show the main content
          document.body.style.overflow = "auto"; // Allow scrolling again
          initVideoCarousel(); // Initialize video carousel and attempt to play music

          // Attempt to play background music on user interaction
          if (backgroundMusic && backgroundMusic.paused) {
            const playPromise = backgroundMusic.play();
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  console.log(
                    "Background music started after user interaction."
                  );
                })
                .catch((error) => {
                  console.warn("Autoplay prevented:", error);
                  // Autoplay was prevented. User might need to manually enable sound.
                });
            }
          }
        }, 500); // Delay to match initialMessage transition
      });

      function setAnimationTimeout(fn, delay) {
        const id = setTimeout(fn, delay);
        animationTimeouts.push(id);
        return id;
      }

      function clearAnimationTimeouts() {
        animationTimeouts.forEach(clearTimeout);
        animationTimeouts = [];
      }

      function animateWeddingText() {
        return new Promise((resolve) => {
          const textContainer = document.getElementById("weddingText");
          const rawText = "Happy Wedding\nMas Rizal & Mbak Desy";
          const chars = Array.from(rawText);

          textContainer.innerHTML = "";
          let visibleCharCount = 0;
          let aborted = false;

          const abort = () => {
            aborted = true;
            textContainer.innerHTML = rawText.replace(/\n/g, "<br>");
            resolve();
          };

          animateWeddingText.abort = abort;

          chars.forEach((char, index) => {
            if (aborted) return;

            let span;
            if (char === "\n") {
              span = document.createElement("br");
              textContainer.appendChild(span);
              return;
            } else {
              span = document.createElement("span");
              span.innerHTML = char === " " ? "&nbsp;" : char;
              span.style.opacity = 0;
              span.style.transition = "opacity 0.3s ease";
              span.style.display = "inline-block";
              textContainer.appendChild(span);

              setAnimationTimeout(() => {
                if (!aborted) {
                  span.style.opacity = 1;
                }
              }, visibleCharCount * 70);

              visibleCharCount++;
            }
          });

          setAnimationTimeout(() => {
            if (!aborted) resolve();
          }, visibleCharCount * 70 + 500);
        });
      }

      function resetComponent2Animations() {
        clearAnimationTimeouts();
        if (animateWeddingText.abort) {
          animateWeddingText.abort();
          animateWeddingText.abort = null;
        }

        ringIcon.classList.remove("animate");
        weddingText.classList.remove("show");
        animatedImages.classList.remove("show");
        weddingBlessing.classList.remove("show");

        weddingText.innerHTML = "Happy Wedding<br />Mas Rizal & Mbak Desy";

        animatedImages.style.transform = "translateY(20px)";
        weddingBlessing.style.transform = "translateY(30px)";
      }

      function hideComponent2Immediately() {
        clearAnimationTimeouts();
        if (animateWeddingText.abort) {
          animateWeddingText.abort();
          animateWeddingText.abort = null;
        }

        ringIcon.classList.remove("animate");
        weddingText.classList.remove("show");
        animatedImages.classList.remove("show");
        weddingBlessing.classList.remove("show");

        weddingText.innerHTML = "";

        animatedImages.style.transform = "translateY(0)";
        weddingBlessing.style.transform = "translateY(0)";
      }

      function triggerRingAnimation() {
        return new Promise((resolve) => {
          // Set flags at the start of animation
          animationInProgress = true;
          component2AnimationCompleted = false;

          console.log("Component 2 animation started.");

          clearAnimationTimeouts();

          // Reset immediately before starting new animation
          resetComponent2Animations();

          setAnimationTimeout(() => {
            ringIcon.classList.add("animate");
          }, 100);

          setAnimationTimeout(() => {
            weddingText.classList.add("show");
            textAnimationPromise = animateWeddingText();

            textAnimationPromise.then(() => {
              setAnimationTimeout(() => {
                animatedImages.classList.add("show");
              }, 200);

              setAnimationTimeout(() => {
                weddingBlessing.classList.add("show");

                // All visual animations are done, set component2AnimationCompleted to true
                component2AnimationCompleted = true;
                animationInProgress = false; // Animation sequence fully completed
                console.log("Component 2 animation finished.");
                resolve();
              }, 600);
            });
          }, 2600);
        });
      }

      // --- Video Carousel Functions dengan Wrap Around Effect ---
      function loadVideos() {
        videoCarousel.innerHTML = "";
        totalVideos = videoList.length;

        videoList.forEach((videoData, index) => {
          const videoItem = document.createElement("div");
          videoItem.classList.add("video-item");

          const videoWrapper = document.createElement("div");
          videoWrapper.classList.add("video-wrapper");

          const videoElement = document.createElement("video");
          videoElement.setAttribute("controls", "");
          videoElement.setAttribute("playsinline", "");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("preload", "metadata");

          const sourceElement = document.createElement("source");
          sourceElement.setAttribute(
            "src",
            `${videoBasePath}${videoData.filename}`
          );
          sourceElement.setAttribute("type", "video/mp4");

          videoElement.appendChild(sourceElement);
          videoWrapper.appendChild(videoElement);

          const captionElement = document.createElement("p");
          captionElement.classList.add("video-caption");
          captionElement.textContent = videoData.caption;

          videoItem.appendChild(videoWrapper);
          videoItem.appendChild(captionElement);
          videoCarousel.appendChild(videoItem);
        });

        // Clone first and last items for seamless wrap around
        if (totalVideos > 1) {
          // Clone last item and prepend
          const lastClone = videoCarousel.lastElementChild.cloneNode(true);
          lastClone.classList.add("clone");
          videoCarousel.insertBefore(
            lastClone,
            videoCarousel.firstElementChild
          );

          // Clone first item and append
          const firstClone = videoCarousel.children[1].cloneNode(true); // children[1] because [0] is now the clone
          firstClone.classList.add("clone");
          videoCarousel.appendChild(firstClone);

          // Set initial position (offset by one because of prepended clone)
          currentVideoIndex = 0;
          const initialOffset = -(currentVideoIndex + 1) * 100;
          videoCarousel.style.transform = `translateX(${initialOffset}%)`;
          videoCarousel.style.transition = "none"; // No transition for initial setup
        }
      }

      // Function to stop all videos in the carousel
      async function stopAllVideos() {
        const allVideoElements = videoCarousel.querySelectorAll("video");
        let anyVideoPlaying = false; // Track if any video is playing or about to play

        const stopPromises = Array.from(allVideoElements).map(async (video) => {
          if (video && !video.paused) {
            anyVideoPlaying = true; // A video was playing
            try {
              await new Promise((resolve) => {
                const checkAndPause = () => {
                  if (video.readyState >= 2) {
                    video.pause();
                    video.currentTime = 0;
                    video.muted = true;
                    resolve();
                  } else {
                    setTimeout(checkAndPause, 10);
                  }
                };
                checkAndPause();
              });
            } catch (error) {
              console.warn("Error stopping video:", error);
              video.pause();
              video.currentTime = 0;
              video.muted = true;
            }
          }
        });

        await Promise.allSettled(stopPromises);
      }

      // New: Function to pause background music
      function pauseBackgroundMusic() {
        if (backgroundMusic && !backgroundMusic.paused) {
          backgroundMusic.pause();
          console.log("Background music paused.");
        }
      }

      // New: Function to resume background music
      function resumeBackgroundMusic() {
        // Attempt to play immediately when called, but handle the promise
        if (backgroundMusic && backgroundMusic.paused) {
          const playPromise = backgroundMusic.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                console.log("Background music resumed.");
              })
              .catch((error) => {
                console.warn(
                  "Failed to resume background music (likely autoplay policy):",
                  error
                );
                // This error often means autoplay was prevented. User interaction will still be needed.
              });
          }
        }
      }
      // Track user interaction (still useful for video playback with sound)
      let userHasInteracted = false;
      let isTransitioning = false; // Flag to prevent multiple transitions

      function detectUserInteraction() {
        if (!userHasInteracted) {
          userHasInteracted = true;
          console.log(
            "User interaction detected - videos can now play with sound."
          );
          // The background music should already be attempting to play on load,
          // but this ensures it plays if the initial attempt failed due to browser policies.
          resumeBackgroundMusic();
        }
      }

      // Add event listeners to detect user interaction
      document.addEventListener("click", detectUserInteraction, {
        once: false,
      });
      document.addEventListener("keydown", detectUserInteraction, {
        once: false,
      });
      document.addEventListener("touchstart", detectUserInteraction, {
        once: false,
      });

      // Function to play a specific video (improved)
      // Function to play a specific video (improved)
      async function playVideo(videoElement) {
        if (!videoElement) return;

        pauseBackgroundMusic(); // Pause music when a video is about to play

        try {
          if (videoElement.readyState < 2) {
            videoElement.load();
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error("Video load timeout"));
              }, 5000);

              const onLoadedData = () => {
                clearTimeout(timeout);
                videoElement.removeEventListener("loadeddata", onLoadedData);
                videoElement.removeEventListener("error", onError);
                resolve();
              };

              const onError = (e) => {
                clearTimeout(timeout);
                videoElement.removeEventListener("loadeddata", onLoadedData);
                videoElement.removeEventListener("error", onError);
                reject(e);
              };

              videoElement.addEventListener("loadeddata", onLoadedData);
              videoElement.addEventListener("error", onError);
            });
          }

          videoElement.currentTime = 0;

          if (userHasInteracted) {
            videoElement.muted = false;
            // --- UBAH INI: Atur volume ke 1.0 (100% maksimal) ---
            videoElement.volume = 1.0;
            // --- END UBAH ---
            try {
              const playPromise = videoElement.play();
              if (playPromise !== undefined) {
                await playPromise;
                console.log("Video playback started with sound");
                return;
              }
            } catch (error) {
              console.log("Failed to play with sound, trying muted:", error);
            }
          }

          videoElement.muted = true;
          // --- UBAH INI JUGA: Atur volume ke 1.0 (100% maksimal) ---
          videoElement.volume = 1.0;
          // --- END UBAH ---
          const playPromise = videoElement.play();

          if (playPromise !== undefined) {
            await playPromise;
            console.log("Video playback started (muted)");
            showUnmuteIndicator(videoElement);
          }
        } catch (error) {
          console.warn("Video playback failed:", error);
          videoElement.pause();
          videoElement.muted = true;
          resumeBackgroundMusic(); // Resume music if video fails to play
        }
      }
      function showUnmuteIndicator(videoElement) {
        const existingIndicator =
          videoElement.parentElement.querySelector(".unmute-indicator");
        if (existingIndicator) {
          existingIndicator.remove();
        }

        const indicator = document.createElement("div");
        indicator.className = "unmute-indicator";
        indicator.innerHTML = "🔊 Tap untuk unmute";
        indicator.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      transition: opacity 0.3s;
    `;

        indicator.addEventListener("click", (e) => {
          e.stopPropagation();
          videoElement.muted = false;
          indicator.remove();
          userHasInteracted = true;
        });

        setTimeout(() => {
          if (indicator.parentElement) {
            indicator.style.opacity = "0";
            setTimeout(() => indicator.remove(), 300);
          }
        }, 3000);

        videoElement.parentElement.style.position = "relative";
        videoElement.parentElement.appendChild(indicator);
      }

      async function showVideo(index, direction = "none") {
        if (isTransitioning) return; // Prevent multiple transitions

        try {
          isTransitioning = true;
          await stopAllVideos();
          await new Promise((resolve) => setTimeout(resolve, 50));

          // Calculate position with clones (add 1 because of prepended clone)
          const targetPosition = -(index + 1) * 100;

          // Enable transition for smooth movement
          videoCarousel.style.transition = "transform 0.3s ease-in-out";
          videoCarousel.style.transform = `translateX(${targetPosition}%)`;

          // Handle wrap around after transition
          const handleTransitionEnd = () => {
            videoCarousel.removeEventListener(
              "transitionend",
              handleTransitionEnd
            );

            // Check if we need to handle wrap around
            if (index === -1) {
              // We went to the clone of last item, now jump to actual last item
              currentVideoIndex = totalVideos - 1;
              videoCarousel.style.transition = "none";
              videoCarousel.style.transform = `translateX(${
                -(currentVideoIndex + 1) * 100
              }%)`;
            } else if (index === totalVideos) {
              // We went to the clone of first item, now jump to actual first item
              currentVideoIndex = 0;
              videoCarousel.style.transition = "none";
              videoCarousel.style.transform = `translateX(${
                -(currentVideoIndex + 1) * 100
              }%)`;
            } else {
              currentVideoIndex = index;
            }

            isTransitioning = false;

            // Play the active video
            const activeVideoElement = getActiveVideoElement();
            if (activeVideoElement) {
              playVideo(activeVideoElement);
            }
          };

          videoCarousel.addEventListener("transitionend", handleTransitionEnd);

          // Fallback in case transitionend doesn't fire
          setTimeout(() => {
            if (isTransitioning) {
              handleTransitionEnd();
            }
          }, 500);
        } catch (error) {
          console.error("Error in showVideo:", error);
          isTransitioning = false;
        }
      }

      function getActiveVideoElement() {
        // Get the actual active video (not from clones)
        const allVideoItems = Array.from(videoCarousel.children).filter(
          (item) => !item.classList.contains("clone")
        );
        return allVideoItems[currentVideoIndex]?.querySelector("video");
      }

      function nextVideo() {
        if (isTransitioning) return;

        if (currentVideoIndex === totalVideos - 1) {
          // Going from last to first - use clone for smooth transition
          showVideo(totalVideos, "forward");
        } else {
          showVideo(currentVideoIndex + 1, "forward");
        }
      }

      function prevVideo() {
        if (isTransitioning) return;

        if (currentVideoIndex === 0) {
          // Going from first to last - use clone for smooth transition
          showVideo(-1, "backward");
        } else {
          showVideo(currentVideoIndex - 1, "backward");
        }
      }

      // Event listeners
      prevVideoBtn.addEventListener("click", () => {
        detectUserInteraction();
        prevVideo();
      });

      nextVideoBtn.addEventListener("click", () => {
        detectUserInteraction();
        nextVideo();
      });

      // Touch controls
      let startVideoX = 0;
      let endVideoX = 0;
      const videoCarouselThreshold = 50;

      videoCarousel.addEventListener("touchstart", (e) => {
        detectUserInteraction();
        startVideoX = e.touches[0].clientX;
      });

      videoCarousel.addEventListener("touchend", (e) => {
        endVideoX = e.changedTouches[0].clientX;
        const diffX = startVideoX - endVideoX;

        if (Math.abs(diffX) > videoCarouselThreshold && !isTransitioning) {
          if (diffX > 0) {
            nextVideo(); // Swipe left - next video
          } else {
            prevVideo(); // Swipe right - previous video
          }
        }
      });

      // Initialize carousel
      function initVideoCarousel() {
        loadVideos();
        // REMOVE or comment out the direct call to resumeBackgroundMusic() here for initial load
        // resumeBackgroundMusic(); // <--- REMOVE THIS LINE OR COMMENT IT OUT
        // Video tidak akan diputar di sini lagi, hanya di goToSlide(2)
      }

      // --- End Video Carousel Functions ---

      function updateProgressBar() {
        progressBarSegments.forEach((segment, index) => {
          if (index === currentIndex) {
            segment.classList.add("active");
          } else {
            segment.classList.remove("active");
          }
        });

        if (currentIndex === 2) {
          btnScroll.classList.add("hidden");
        } else {
          btnScroll.classList.remove("hidden");
        }
      }

      function goToSlide(index) {
        const previousIndex = currentIndex;
        currentIndex = index;
        carouselInner.style.transform = `translateY(-${currentIndex * 100}vh)`;
        updateProgressBar();

        // Handle animations for component 2
        if (currentIndex === 1) {
          stopAllVideos(); // Stop videos when entering component 2
          resumeBackgroundMusic(); // Ensure music resumes when on component 2

          // Only trigger animation if it's not already running AND hasn't completed yet
          if (!animationInProgress && !component2AnimationCompleted) {
            triggerRingAnimation();
          } else if (component2AnimationCompleted) {
            // If animation completed previously, just ensure elements are shown without re-animating
            ringIcon.classList.add("animate");
            weddingText.classList.add("show");
            weddingText.innerHTML = "Happy Wedding<br />Mas Rizal & Mbak Desy";
            animatedImages.classList.add("show");
            weddingBlessing.classList.add("show");
          }
        } else if (previousIndex === 1) {
          // When leaving component 2, reset animations and flags
          resetComponent2Animations();
          hideComponent2Immediately();
          animationInProgress = false;
          component2AnimationCompleted = false;
        }

        // Handle animations and video for component 3
        if (currentIndex === 2) {
          pauseBackgroundMusic(); // Pause music when entering component 3

          heading3.classList.add("aos-animate", "aos-zoom-in");
          subtext3.classList.add("aos-animate", "aos-fade-up");
          videoCarouselContainer.classList.add("aos-animate", "aos-fade-up");

          setTimeout(() => {
            heading3.style.transitionDuration = "1000ms";
            subtext3.style.transitionDelay = "500ms";
            videoCarouselContainer.style.transitionDelay = "800ms";
          }, 50);

          showVideo(currentVideoIndex);
        } else if (previousIndex === 2) {
          heading3.classList.remove("aos-animate", "aos-zoom-in");
          subtext3.classList.remove("aos-animate", "aos-fade-up");
          videoCarouselContainer.classList.remove("aos-animate", "aos-fade-up");

          heading3.style.transitionDuration = "";
          subtext3.style.transitionDelay = "";
          videoCarouselContainer.style.transitionDelay = "";

          stopAllVideos(); // Stop videos when leaving component 3
          resumeBackgroundMusic(); // Resume music when leaving component 3
        }

        // --- Add this block to handle music for component 1 ---
        if (currentIndex === 0) {
          stopAllVideos(); // Ensure no videos are playing
          resumeBackgroundMusic(); // Play background music for component 1
        }
        // --- End of added block ---

        // Ensure music is playing if not on component 3 and no video is playing
        if (currentIndex !== 2) {
          // Check if any video is currently playing after a short delay
          // This is a safety net in case video transitions are slow
          setTimeout(() => {
            const allVideoElements = videoCarousel.querySelectorAll("video");
            const anyVideoCurrentlyPlaying = Array.from(allVideoElements).some(
              (video) => !video.paused && !video.ended
            );
            if (!anyVideoCurrentlyPlaying) {
              resumeBackgroundMusic();
            }
          }, 500);
        }
      }
      // Event listener untuk button scroll dengan proteksi
      btnScroll.addEventListener("click", (e) => {
        // If on component 2 and animation is in progress, prevent changing slide
        if (currentIndex === 1 && animationInProgress) {
          console.log("Click ignored - Component 2 animation is running");
          e.preventDefault(); // Mencegah tindakan default tombol
          return;
        }

        // Only allow scrolling forward from component 0 and 1
        if (currentIndex < maxIndex) {
          currentIndex++;
          goToSlide(currentIndex);
        }
        // If already at maxIndex (component 2), do nothing or reset to 0 based on desired behavior
        // For now, it will stay at maxIndex
      });

      // Event listener untuk klik layar dengan proteksi
      document.addEventListener("click", function (e) {
        // Skip jika klik pada button atau elemen control
        if (
          e.target.closest("button") ||
          e.target.closest(".control-element") ||
          e.target.closest(".unmute-indicator")
        ) {
          return;
        }

        // If on component 2 and animation is in progress, prevent changing slide
        if (currentIndex === 1 && animationInProgress) {
          console.log(
            "Screen click ignored - Component 2 animation is running"
          );
          e.preventDefault();
          e.stopPropagation(); // Stop propagation to prevent other click handlers from firing
          return;
        }

        // Perform normal navigation if not protected
        // This will only go to the next slide
        if (currentIndex < maxIndex) {
          currentIndex++;
          goToSlide(currentIndex);
        } else {
          // If at the last slide, loop back to the first or stay
          currentIndex = 0; // Or keep it at maxIndex if you don't want to loop
          goToSlide(currentIndex);
        }
      });

      progressBarSegments.forEach((segment, index) => {
        segment.addEventListener("click", () => {
          goToSlide(index);
        });
      });

      let startY = 0;
      let endY = 0;
      const threshold = 50;

      const carouselContainer = document.getElementById("carouselContainer");

      carouselContainer.addEventListener(
        "touchstart",
        (e) => {
          startY = e.touches[0].clientY;
          isSwiping = false; // Reset flag
        },
        { passive: true }
      ); // Gunakan passive: true untuk peningkatan kinerja (tidak akan memanggil preventDefault di touchstart)

      carouselContainer.addEventListener(
        "touchmove",
        (e) => {
          // Hanya jika satu jari disentuh dan belum ada swipe aktif
          if (e.touches.length === 1 && !isSwiping) {
            const currentY = e.touches[0].clientY;
            const diffY = startY - currentY;

            // Jika pergerakan vertikal cukup signifikan untuk dianggap sebagai swipe
            if (Math.abs(diffY) > 5) {
              // Sedikit toleransi sebelum menandai sebagai swipe
              isSwiping = true;
              // Jika ini adalah swipe vertikal, cegah default agar tidak memicu pull-to-refresh
              // Penting: hanya panggil preventDefault jika Anda yakin ingin mengelola scroll secara manual
              e.preventDefault();
            }
          }
        },
        { passive: false } // Gunakan passive: false agar preventDefault bisa berfungsi
      );

      carouselContainer.addEventListener("touchstart", (e) => {
        startY = e.touches[0].clientY;
      });

      carouselContainer.addEventListener("touchend", (e) => {
        if (isSwiping) {
          // Hanya proses jika ada swipe vertikal yang terdeteksi
          endY = e.changedTouches[0].clientY;
          const diffY = startY - endY;

          // Add protection for swipe gestures on Component 2
          if (currentIndex === 1 && animationInProgress) {
            console.log("Swipe ignored - Component 2 animation is running");
            isSwiping = false; // Reset flag
            return;
          }

          if (diffY > threshold) {
            // Swipe Up (pindah ke komponen berikutnya)
            currentIndex++;
            if (currentIndex > maxIndex) {
              currentIndex = maxIndex; // Batasi agar tidak melebihi indeks terakhir
            }
          } else if (diffY < -threshold) {
            // Swipe Down (pindah ke komponen sebelumnya)
            currentIndex--;
            if (currentIndex < 0) {
              currentIndex = 0; // Batasi agar tidak kurang dari indeks pertama
            }
          }
          goToSlide(currentIndex);
          isSwiping = false; // Reset flag setelah selesai
        }
      });

      carouselContainer.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault(); // Mencegah scrolling default browser

          // Add protection for wheel events on Component 2
          if (currentIndex === 1 && animationInProgress) {
            console.log("Wheel ignored - Component 2 animation is running");
            return;
          }

          if (e.deltaY > 0) {
            // Gulir ke bawah (pindah ke komponen berikutnya)
            currentIndex++;
            if (currentIndex > maxIndex) {
              currentIndex = maxIndex;
            }
          } else {
            // Gulir ke atas (pindah ke komponen sebelumnya)
            currentIndex--;
            if (currentIndex < 0) {
              currentIndex = 0;
            }
          }
          goToSlide(currentIndex);
        },
        { passive: false } // Penting: Gunakan passive: false untuk memungkinkan preventDefault
      );
    </script>
  </body>
</html>
